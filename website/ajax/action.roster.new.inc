<?php
// $_POST roundid, roundid_<nnn>, classname, top, bucketed

// Populates a new round by selecting top finishers from a previous round or rounds.

// If $_POST['roundid'] is not empty, it identifies a completed round, and
// implies that we're populating a new follow-on round for the same class, based
// on the top finishers from the identified round.
//
// If roundid is empty, then we're generating an aggregate round, taking top
// finishers across multiple previous rounds.  There are two ways this can happen:
//
// - If $_POST['classname'] is present, then we're creating an aggregate round for
//    a new aggregate class.  $_POST['classname'] will be taken as the name of
//    the new class.
//
//    The rounds whose results feed into the new aggregate round are identified
//    by $_POST keys of the form $_POST['roundid_<nnn>'].
//
//  - If $_POST['classid'] is present, then we're creating an aggregate round
//    based on a defined aggregate class.  The rounds whose results feed into
//    the new aggregate round will be the highest defined round for each of the
//    aggregate class' constituent classes.
//
// $_POST['top'] identifies how many racers to select for the new round, but its
// interpretation also depends on $_POST['bucketed'].
//
// For an aggregate round, if $POST['bucketed'] is true, then $_POST['top']
// tells how many racers to choose from each of the prior rounds feeding in to
// the new round.
//
// For a non-aggregate round, if $_POST['bucketed'] is true, then $_POST['top']
// tells how many racers to choose from each subgroup.
//
// For an "aggregate round by subgroup", we need two or more subgroups, posted
// as $_POST['rankid_<nnn>'].  For each requested subgroup, we look at the
// highest-numbered round for the corresponding (organic) class.
//
// (Note that this ignores any racing aggregate rounds that might draw racers
// from the requested subgroups.)


start_response();

require_once('inc/classes.inc');
require_once('inc/newracer.inc');
require_once('inc/aggregate_round.inc');
require_once('inc/roster.inc');
require_once('inc/rounds.inc');

$bucket_limit = $_POST['top'];
$bucketed = isset($_POST['bucketed']) && $_POST['bucketed'];
$rankids = array();

if (isset($_POST['roundid']) && strlen($_POST['roundid']) > 0) {
  $how_to_bucket = ROSTER_BUCKETED_ORGANIC;
  $roundid = $_POST['roundid'];
  $constituent_roundids = array($roundid);
  list($classid, $old_round) = read_single_row('SELECT classid, round FROM Rounds'
                                               .' WHERE roundid = :roundid',
                                               array(':roundid' => $roundid));
  // TODO: Handle not-found case
  $new_round = 1 + $old_round;
} else {
  $how_to_bucket = ROSTER_BUCKETED_AGGREGATE;

  // A new aggregate round starts at round 1 and may create a new pseudo-class
  // for the aggregate.
  $new_round = 1;

  if (isset($_POST['classname'])) {
    $constituent_roundids = array();
    list($classes, $classseq, $ranks, $rankseq) = classes_and_ranks();
    $highest_rounds = class_highest_rounds();
    foreach ($_POST as $key => $value) {
      if (substr($key, 0, strlen('roundid_')) == 'roundid_') {
        $constituent_roundids[] = substr($key, strlen('roundid_'));
      } else if (substr($key, 0, strlen('rankid_')) == 'rankid_') {
        $r = substr($key, strlen('rankid_'));
        $rankids[] = $r;
        $constituent_roundids[] = $highest_rounds[$ranks[$r]['classid']];
      }
    }
    $constituent_roundids = array_unique($constituent_roundids);
    if (count($rankids) > 0) {
      $how_to_bucket = ROSTER_BUCKETED_AGGREGATE_BY_SUBGROUP;
    }

    $classid = create_aggregate_class($_POST['classname'], $constituent_roundids, false);
    // TODO: Handle 0 or 1 roundid's provided
  } else {
    $classid = $_POST['classid'];
    $details = read_single_row('SELECT'
                               .(schema_version() >= 3 ? ' constituents,' : ' \'\' AS constituents,')
                               .(schema_version() >= 5 ? ' rankids' : ' \'\' AS rankids,')
                               .' FROM Classes'
                               .' WHERE classid = :classid',
                               array(':classid' => $classid),
                               PDO::FETCH_ASSOC);

    $constituent_roundids = highest_rounds($details['constituents']);
    if (!empty($details['rankids'])) {
      $rankids = array_filter(explode(',', $details['rankids']), 'strlen');
      $how_to_bucket = ROSTER_BUCKETED_AGGREGATE_BY_SUBGROUP;
    }
  }
}

// With $new_round and $classid settled, make the new round (unless it
// already exists)

$new_roundid = read_single_value('SELECT roundid FROM Rounds'
                                 .' WHERE round = :round'
                                 .'  AND classid = :classid',
                                 array(':round' => $new_round,
                                       ':classid' => $classid),
                                 0);
if ($new_roundid) {
  // If found a Rounds entry, then we're repeating making a roster.
  // Delete the old entries.
  $stmt = $db->prepare('DELETE FROM Roster WHERE roundid = :roundid');
  $stmt->execute(array(':roundid' => $new_roundid));
} else {
  // The usual case: make a whole new round
  $new_roundid = make_new_round($classid, $new_round);
}

populate_roster($bucketed ? $how_to_bucket : ROSTER_UNBUCKETED, $new_roundid, $classid, $bucket_limit,
                $constituent_roundids, $rankids);

echo "<new-round roundid=\"".$new_roundid."\"/>\n";
echo "<success/>\n";

require('ajax/query.poll.coordinator.inc');

end_response();

?>
